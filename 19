# unet_synthetic_segmentation.py
# Purpose: implement small UNet and train on synthetic circle masks
# Run in Colab/Jupyter. Requires: tensorflow, numpy, skimage

import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from skimage.draw import disk
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
np.random.seed(42)
tf.random.set_seed(42)

# 1) Create synthetic dataset: images 64x64 with random circles (foreground) on background
IMG_SIZE = 64
N_SAMPLES = 400

def make_sample():
    img = np.zeros((IMG_SIZE, IMG_SIZE), dtype=np.float32)
    mask = np.zeros_like(img)
    # random number of circles 1-3
    n = np.random.randint(1,4)
    for _ in range(n):
        r = np.random.randint(5,15)
        cx = np.random.randint(r, IMG_SIZE-r)
        cy = np.random.randint(r, IMG_SIZE-r)
        rr, cc = disk((cx,cy), r, shape=img.shape)
        img[rr,cc] = np.random.uniform(0.6,1.0)  # intensity
        mask[rr,cc] = 1
    # add noise
    img += np.random.normal(0, 0.05, img.shape)
    img = np.clip(img, 0, 1)
    return img, mask

X = np.zeros((N_SAMPLES, IMG_SIZE, IMG_SIZE, 1), dtype=np.float32)
Y = np.zeros((N_SAMPLES, IMG_SIZE, IMG_SIZE, 1), dtype=np.float32)
for i in range(N_SAMPLES):
    im, m = make_sample()
    X[i,...,0] = im
    Y[i,...,0] = m

X_train, X_val, y_train, y_val = train_test_split(X, Y, test_size=0.2, random_state=42)

# 2) Small UNet
def conv_block(x, filters):
    x = layers.Conv2D(filters, 3, padding='same', activation='relu')(x)
    x = layers.Conv2D(filters, 3, padding='same', activation='relu')(x)
    return x

def encoder_block(x, filters):
    c = conv_block(x, filters)
    p = layers.MaxPooling2D((2,2))(c)
    return c, p

def decoder_block(x, conv_features, filters):
    x = layers.UpSampling2D((2,2))(x)
    x = layers.Concatenate()([x, conv_features])
    x = conv_block(x, filters)
    return x

inputs = layers.Input((IMG_SIZE, IMG_SIZE, 1))
c1, p1 = encoder_block(inputs, 16)
c2, p2 = encoder_block(p1, 32)
b = conv_block(p2, 64)
d1 = decoder_block(b, c2, 32)
d2 = decoder_block(d1, c1, 16)
outputs = layers.Conv2D(1, 1, activation='sigmoid')(d2)
model = models.Model(inputs, outputs)
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.summary()

# 3) Train
history = model.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=20, batch_size=16, verbose=1)

# 4) Evaluate & visualize sample results
loss, acc = model.evaluate(X_val, y_val, verbose=0)
print("Val loss, acc:", loss, acc)

# Show a few predicted masks
preds = model.predict(X_val[:6])
for i in range(3):
    plt.figure(figsize=(8,3))
    plt.subplot(1,3,1); plt.imshow(X_val[i,:,:,0], cmap='gray'); plt.title('Image'); plt.axis('off')
    plt.subplot(1,3,2); plt.imshow(y_val[i,:,:,0], cmap='gray'); plt.title('True Mask'); plt.axis('off')
    plt.subplot(1,3,3); plt.imshow((preds[i,:,:,0]>0.5).astype(int), cmap='gray'); plt.title('Pred Mask'); plt.axis('off')
    plt.show()
